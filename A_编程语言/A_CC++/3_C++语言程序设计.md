# C++ 使用手册

## 语法基础

注释：

- 行注释：//
- 块注释：/**/

### 一、内存模型

1、代码区：存放函数的二进制代码，由操作系统管理

2、全局区：存放全局变量和静态变量以及常量

- 全局变量、静态变量、常量区、字符串常量、const定义的常量

3、栈区：由编译器自动分配释放，川航函数参数、局部变量

4、堆区：程序员控制，程序结束自动释放

- 使用new运算符

### 二、引用

#### 1、引用的基本用法

理解：给变量起别名，他们都指向同一块内存。

语法：数据类型 &别名 = 原名

① 普通变量引用

``` c++
int a = 100;
// 例子：
int &b = a; 
// 修改b，a的值也修改，他们是同一块内存
b = 20；
printf("%d", a);

// 错误引用，引用必须是一个合法的空间
int &b = 100;
```

② 数组引用

``` c++
int a[10] = {0};
//给数组起别名,arr指向a的空间
int (&arr)[10] = a; 
```

③ 函数引用

``` c++
int &cc = func(); //引用类型的函数
```

#### 2、引用的注意事项

- 引用必须初始化
- 引用初始化后不可修改
- 并没有引用变量（与指针不同），当去掉&符号，就是普通变量（而指针，只要声明了指针变量，他就一直是指针变量，不论带不带*）

``` c++
/* 引用必须初始化 */ 
int &a; //错误，没有初始化

/* 引用后不能修改 */
int b = 200;
int &c = b;
&c = 300; //错误，引用已经指向了b
c = 300;  //这是赋值操作，不是引用，正确
```

#### 3、引用做函数参数

- 本质还是指针传值，但比指针传值简单

``` c++
// 定义引用传值，注意这里的&
void swap(int &a, int &b)
{
	//通过别名的方式操作数据，本质也是操作地址
	int temp = a;
	a = b;
	b = tmp;
}

int main(){
	int a=200;
	int c=100;
    // 引用传递，这里放的是值
    // 这样就与其他高级语言一样简单
	swap(a, b);
}
```

#### 4、引用做函数的返回值

- 不要返回局部变量的引用，因为这个引用会销毁
- 函数的调用可以做左值

``` c++
/* 局部变量不要返回 */ 
int & test(){
    int a = 10;
    return a;
}
int &ref = test();
cout << ref << endl; //打印错误，第一次可能成功

/* 函数的引用可以做为 */
int & test(){
    // 全局区，程序结束后释放
    static int a = 10;
    return a;
}
int &ref = test();
cout << ref << endl; //打印10，因为他是static变量
// 这里test返回一个引用，相当于&ref = 1000
test() = 1000;
cout << ref << endl; // 打印1000
```

#### 5、常量引用

``` c++
//
const int & ref = 10;
// ref不能修改
ref = 20;

void test(const int &val)
{
    val = 100; //错误不能修改
}
```

### 三、hello world

``` c++
// <> 系统头文件
// "" 自定义头文件，当前文件所在的目录
#include <iostream> //标准输入输出流
//使用命名空间
useing namespace std； 

int main(int argc, const char * argv[]){
    // 标准的命名空间std
    // cout标准输出
    // << 左运算符，拼接基础类型，字符串
    // endl换行
	std::cout << “hello world” << std::endl;
	system(“pause”);//阻塞

	return EXIT_SUCCESS; // 返回正常退出
}
```

## 

## 作用域

#### 1、:: 运算符

```c++
// 作用域运算符
// 全局atc ::atc 
int atc=100;
void function()
{
	cout << ::atc <<endl //使用全局atc
	std::cout //std作用域下的cout方法
}
```

#### 2、namespace关键字

```c++
//命名空间必须定义在全局作用下
//命名空间可以嵌套命名空间
//命名空间可以放函数，变量，结构体类
//命名空间是开放的，可以随时添加进原来的命名空间，**同一个命名空间名会合并**
namespace LOL  // 声明一个命名空间
{
	void goattc();//函数
	int a;//变量
	struct Person{};//结构体
class B{};//类
namespace D{};//命名空间LOL::D::
}

//无名称的命名空间
namespace
{
int a; //相当于static int a;
}
```

#### 3、using关键字

``` c++
//using编译指令
using namespace name 
//use声明，在函数内使用会有二义性，声明原则比编译指令高，
using name 
```

## 标准输入输出

#### 1、键盘输出cout

``` c++
// 跳过回车，空格
// 默认按十进制输出
cout << 0b00001010 << endl; //输出10
cout << 0123 <<endl; //输出83
cout << 0xab << endl; //输出171

// 输出8进制
cout << bitset<8>(0b00001010) << endl; // 输出00001010
cout << oct << 0123<< endl; // 0123
cout << hex << 0xab << endl; //输出ab
//刷新缓冲区linux有用
cout.flush()
//放入缓冲区
cout.put(‘a’).put() 
// 
cout.write()
cout.width(20)
cout.fill(“*”)
//卸载10进制显示
cout.unsetf(ios::dec)
//十进制显示
cout.setf(ios::dec)
```

#### 2、键盘输入cin

``` c++
// cin 输入设备，默认为键盘
char data;
// cin会根据输入的类型自动判断输入类型
cin >> data; //将输入值放入data变量
// 输入多个变量
cin >> num >> data
//获取一个字符，接收换行\n
char c = cin.get() 
//将字符放到buf变量中，获取1024个字符,读取字符串不会拿走\n需要在读取一次
cin.get(buf, 1024)
//读取换行符，并把换行扔掉
cin.getline(buf, 1024)
//忽略一个字符
cin.ignore()
//忽略了n个字符
cin.ignore(n)
//查看，然后再放入缓存区，用cin.get()可获取
cin.peek()
//将字符串返回缓冲区
char c = cin.get();
cin.putback(c); 
```

字符类型 

## New运算符

#### 1、创建空间

- 返回的是该类型的指针

``` c++
// 创建10个int类型的空间
int *p = new int(10);
    
// 开辟数组,10个连续空间的数组
int *arr = new int[10];
    
// 函数
int * func(){}
int *p = func()
```

#### 2、删除空间

```c++
// 普通变量
int *p = new int(10)
// 删除
delete p;

// 释放数组
int *p = new int[10];
// 释放整个数组
delete[] arr;
// 释放一个值
delete arr[2];
```

## string类型

### 一、使用

``` c++
// 必须导入库
#include <string>
// new一个string类型字符串
string *name;
name = new string("xxxxx")
```



## 函数高级

### 一、默认参数

- 如果有一个值有默认参数，从这个位置开始，到最后面都必须有默认参数
- 定义和声明，只能有1个默认参数。

``` c++
// 声明
int func(int a = 1111);
// 从b开始到最后都必须有默认参数
int func(int a, int b =1, int c=2);

// 定义
int func(int a = 1111){
    return a;
}

/* 定义-实现 */
// 声明中含有默认参数
int func(int a=1);
int func(int a){
    return 1;
}
// 定义中含有默认参数
int func(int a);
int func(int a=1){
    return 1;
}
```

### 二、占位参数

``` c++
// 第二个参数是占位参数
void func(int a, int){
    return 1;
}
func(1,2)
    
// 占位参数的默认值
void func(int = 10){
    return 1;
}
func()
```

### 三、函数重载

函数名相同，但参数不同，从而根据参数选择不同的函数

- 参数不同包括，个数、类型、顺序、引用类型
- 函数的返回值，不能变成重载方式
- 重载，不加默认参数

#### 1、正常调用

``` c++
void func(int a){
    count << "func的调用——1"
}
void func(){
    count << "func的调用——2"
}

// 输出func的调用——1
func(1);
// 输出func的调用——2
func();
```

#### 2、常量

``` c++
/* 常量 */
void func(int a){
    count << "func的调用——1"
}
void func(const int a){
    count << "const int a"
}
int v = 10;
// 输出func的调用——1
func(v);
// 输出 const int a
func(10);
```

#### 3、常量引用

``` c++
/* 常量引用 */
void func(int &a){
    count << "func的调用——1"
}
// 无法引用，因为相当于int &a=10，非法
// 引用 只能引用变量
func(10);

void func(const int &a){
    count << "const int a"
}
// 合法，因为const是常量
func(10);
```



## 类和对象

### 类的调用方法集合

类方法调用

``` C++
class WorkManager{ ... }

WorkManager worker;
worker.print_title();
```

指针方法调用

``` c++
class WorkManager{ ... }

WorkManager *worker = new WorkManager;
worker->print_title();
```

### 一、封装

#### 1、分文件编写类

①、创建类的头文件（NPC.h）

``` c++
#ifndef __xxx
#define __xxx
class NPC 
{
    // 构造和析构，必须在public下，或者什么都每没加的地方
	NPC()；  //构造方法,与类名相同
	~NPC()； //析构方法
private:
protected:
public:
    //成员属性
	int Name；
    //定义一个方法
	void move(int a); 
}
#endif //宏定义
```

②、创建类的.cpp文件（NPC.cpp）

``` c++
// 引入头文件
#include “NPC.h” 

NPC::NPC(){} //实现构造方法
NPC::~NPC(){ //析构方法
	delete this->a; //释放空间a
} 

//::成员操作符
void NPC::move(int a){ 
	std::cout << “1”;
}
```

③、在其他文件中使用类

``` c++
// 引入类的头文件
#include “NPC.h”

int main() {
    /* 普通方法 */
	NPC n1    // 实例化
	n1.move(1) // 调用NPC类中的方法move
	
    /* 使用new方法创建类 */
	NPC *n2；
    // 为什么要用指针，因为new返回一个该类型的指针
	n2 = new NPC() 
    n2 = &n1     // 可以指向一个已经创建的对象
        
	/* 构造函数调用 */
	NPC n3(1) //调用构造函数
	NPC * n3 = new NPC(1)
}
```

#### 2、类引用第三方类

``` c++
#ifndef __xxx
#define __xxx
// 第三方类
class Rect{ ... } 
// 引用的类
class NPC 
{
    //引用另外的类
	Rect * a; 
}
#endif //宏定义
```

#### 3、类的访问权限

- public

  方法，属性类外类内都可以使用

- protected

  方法、属性类内可以，类外不能访问

  子类可以访问父类的protected方法

- private

  默认权限，方法、属性类内可以，类外不能访问

  子类不可以访问父类的protected方法

另外：静态方法，属性不属于类的对象

``` c++
class AA(){
    static int m; //静态成员不属于类
	static void func3(); //静态成员函数不属于对象
}
```

#### 4、结构体和类的区别

主要区别就是默认权限不同，struct默认为公共，class默认权限是私有

#### 5、将成员属性设为私有

优势：可以自己控制读写权限，可以检查数据的有效性

``` c++
class Person
{
// 设置属性权限为私有
private:
    string name;
    int age;
// 提供修改属性的公共方法
public:
    // 修改名称方法，类外调用
    void fix_name(string a){
        // 这里可以验证字符串是否符合要求
    }
}
```

### 二、对象特性

#### 1、构造函数

``` c
class NPC 
{
    // 构造方法,与类名相同,自动调用
    // 构造函数可以有参数，可以重载
	NPC()；  
}

/* 单文件 */
class NPC 
{
	NPC(){
        count<< "构造函数调用"；
    }  
}
```

#### 2、析构函数

``` c++
class NPC 
{
    // 析构方法，与类名相同，自动调用
	~NPC();
}
```

#### 3、构造函数的分类

共2种分类方式：

- 按参数分为：有参数构造和无参数构造
- 按类型分为：普通构造和拷贝构造

#### 4、有参构造函数

定义：

``` c++
/* 有参数构造函数 */
class NPC 
{
	NPC(int a);
}
```

调用方法：

``` c++
/* 括号法 */
//默认构造函数, 不要加小括号
NPC p1; 
// 有参数构造函数
NPC p2(10); 

/* 显示法 */
// 有参数构造
NPC p4 = NPC(10);


/* 隐试转换法 */
// 相当于 NPC p6 = NPC(10)
NPC p6 = 10
```

#### 5、拷贝构造函数

定义：

``` c++
/* 拷贝构造函数 */
class NPC 
{
    // 固定写法
    // 拷贝构造函数，需要把类传入
	NPC(const NPC &n);
}
```

调用：

``` c++
NPC p2;

/* 括号法 */
NPC p3(p2);

/* 显示法 */
// 不要使用拷贝函数初始化匿名对象
// 例：NPC(p5) 
// NPC(p5) 等价于 NPC p5,这时p5与13行对象名相同
NPC p5 = NPC(p2);

/* 隐试转换法 */
NPC p7 = p2;
```

#### 6、深拷贝和浅拷贝

浅拷贝：并没有正在的拷贝，而是用指针指向了同一块空间，是由于析构（释放）内存时，浅拷贝在第一次就把资源释放，第二次释放就出错了

深拷贝：在堆中重新申请空间

``` c++
NPC(const NPC & N){
    // 自己在构造时自定义一个
    m_Height = new int(*N.m_Height)
}
~NPC(){
    if(m_Height !=NULL){
        delete m_Height;
    }
}
```

#### 7、拷贝构造函数使用时机

1、用已经创建好得对象初始化新类(Person p2(p1))

2、值传递，将类作为参数（值传递，都会调用拷贝构造）

3、以值得方式返回局部对象（会占用更多内存）

relese与debug模式运行结果不同

#### 8、初始化列表

给类的属性赋值的操作

①、传统操作

``` c++
class Person{
	//Person中定义属性
	int m_A; 
    int m_B;
    
	Person(int a, int b){
        m_A = a;
        m_B = b;
    }
}
```

②、使用初始化列表

``` c++
class Person {
	//Person中定义属性
	int m_A; 
    int m_B;
    /* 方法一 */
    //直接将m_A赋值为10，m_B=20
    Person():m_A(10), m_B(20) {
        ... 
    } 
    
    /* 方法二 */
    // 将变量a的值赋值给m_A，将变量b的值赋值给m_B
    Person(int a, int b): m_A(a), m_B(b) { 
        ... 
    }
}
```

#### 9、类对象作为类成员

构造流程：以下例子，先构造A的对象，再构造B的对象

析构流程：以下例子，先析构B的对象，再构造A的对象

``` c++
/* 多个类赋值例子 */ 
class A {
    string name;
    A(string b_na){
    	name = b_na
    }
}
// 在B中定义一个属性，这个属性是自定义的一个类
class B {
    A b_name;
    int b_b;
    // 构造函数中赋值
    // 注意这里的b_name(n)等价于
    // A b_name = n;
    B(int a, string n):b_b(a), b_name(n){
		... 
    }
}

// 调用
B p(1, 'name')
```

#### 10、静态成员变量

静态成员变量

- 所有对象共享同一份数据
- 静态变量在编译的时候就已经创建
- 类内声明，类外初始化
- 类也有访问权限的private下的静态成员变量，类外只能初始化，不能使用

``` c++
class A {
public:
    // 声明
	static int m_age; 
}

// 类内声明，类外初始化
int A::m_age = 100;

// 方法一，通过对象访问
// 先初始化类，再调用类
A value；
value.m_age = 200;

// 方法二，通过类名访问
A::m_age = 300;
```

#### 11、静态成员函数

静态成员函数

- 所有对象共享一个函数
- 静态成员函数只能访问静态成员变量（因为）

``` c++
class A {
public:
    // 静态成员函数只能访问静态成员变量
	static void func(); 
}

// 调用一，通过对象
A a;
a.func();
// 调用二，通过类名
A::func();
```

#### 12、this指针

this指针指向被调用的成员函数（谁调用，就指向谁）

this指针用途：

- 当形参和成员变量同名时，可用this区分
- 在类的非静态成员函数中返回对象本身，可使用return *this

①、解决名称冲突

``` c++
class Person {
	int age;
    Person(int age){
        // 属性名与方法名重名
        this->age = age
    }
}
// this指针指向的时p1
Person p1(18);
```

②、返回类本身（可进行链式编程）

```c++
class Person
{
public:
    int age;
    // 若返回值(Person func(int a))，就不会进行累加操作
    Person & func(int a){
        this->age +=a;
        return * this
    }
}

Person p1;
p1.func(10).func(20).func(30);
```

#### 13、空指针

``` c++
class Person
{
public:
    int age;
    // 若返回值(Person func(int a))，就不会进行累加操作
    void func(){
        cout << "this this kong";
    }
    void func2(){
        // 因为默认成员属性前面有this->
        // 当空指针类的时候，就变成NULL->age
        cout << age;
    }
}

Person *p1 = NULL;
p1.func(); // 没错
p1.func2();// 报错
```

#### 14、const修饰成员函数\属性

①、常函数

- 限制修改类属性的值

``` c++
class Person{
    // 加了mutable，就可以修改
    // 灿han'shu
	mutable int B;
	int a;
    //常函数，不允许修改类的成员属性
	void showInfo() const {
        // 错误，不能修改
		this->a = 100;
        // 正确，mutable是可以修改的
        this->B = 100;
	}
}
```

②、常对象

- 常对象可以调用常函数，不能调用普通方法

``` c++
class Person{
	mutable int B;
	int a;
    //常函数，不允许修改类的成员属性
	void showInfo() const {
        // 错误，不能修改
		this->a = 100;
        // 正确，mutable是可以修改的
        this->B = 100;
	}
    // 普通方法
    void func(){...}
}

const Person p2; 
p2.a = 100; // 错误，不能修改
p2.B = 100; //正确，mutable修饰，可以修改
cout << p2.name // 可以读
    
const Person p3;
p3.func(); // 错误，不能调用
p3.showInfo();// 正确，可以调用常函数
```

### 三、友元函数

可以访问指定类中的私有方法、属性

①、全局函数做友元

``` c++
// 定义
class Buliding {
    // 告诉编译器，允许goodGay() 函数访问私有属性
	friend void goodGay(Buliding &bul);
}

//全局友元函数
// void goodGay(buliding * bul)
void goodGay(buliding &bul）{
	//这里可以调用Buliding访问私有方法属性
}
```

②、类做友元

``` c++
// 定义
class Buliding{
    // 告诉编译器，允许goodGy 类访问私有属性
	friend class goodGy；//类做友元
}
class GoodGay {
    void visite(){  }
}
```

③、成员函数做友元

``` c++
// 定义
class Buliding{
    // 告诉编译器，允许GoodGay类下的visit方法访问
	friend void GoodGay::visit()；//类做友元
}
class GoodGay {
    void visit(){  }
}
```

### 四、运算符重载

对已有的运算符进行重新定义，赋予另外一种功能

#### 1、加法重载

①、通过成员函数重载

``` c++
class Person {
public:
    int a;
    int b;
    //重载+号运算
	Person operator+(Person &p){
        return this.a+ p.b;
    } 
}

// 初始值
Person p1;
p1.a = 10;
Person p2;
p2.b = 20;

// 调用
// 本质是Person p3 = p1.operator+(p2);
Person p3 = p1+p2;
```

②、通过全局函数重载

``` c++
class Person{
    int a;
    int b;
}
// 全局函数重载
Pserson operator+(Person &p1, Person &p2){
    return p1.a+p2.b;
}

// 初始值
Person p1;
p1.a = 10;
Person p2;
p2.b = 20;

// 调用
// 本质：Person p3 = operator+(p1, p2);
Person p3 = p1+p2;
```

#### 2、左移运算符

只通过全局函数重载

``` c++
// 全局函数重载
void operator<< (ostream &cout, Person p){
    cout << p.m_a
}


// 重写左移运算符
Person p;
p.m_a = 100;
cout << p;

/* 链式调用 */
// 链式返回
ostream operator<< (ostream &cout, Person p){
    cout << p.m_a;
    return cout;
}
cout <<p <<p << endl;
```

#### 3、递增运算符重载

``` c++
```

#### 4、赋值运算符重载

#### 5、关系运算符重载

#### 6、函数运算符重载

### 五、继承

#### 1、基本语法

①、父类 base.h

``` c++
class Base {}
```

②、子类 

继承方式：

- public：父类的public、protected权限到子类中不变
- protected：父类的public、protected到子类中都变protected权限
- private：父类的public、protected到子类中权限都变为private
- 父类的private权限不允许继承

``` c++
// 引入要父类的头文件
#include “base.h” 
// 继承base类，默认是private继承
class chile : Base {} 
// 继承多个父类,Base、Base2
class chile : Base, Base2 {} 

/* 继承方式 */
// 公众继承
class chile : public Base {} 
// Base中的类public protected private不变
class chile : protected Base {} //保护继承
// Base中的public 变为 protected
class chile : private Base {} //父类属性变为private
// Base中的private protected变为private
```

#### 2、调用父类构造函数

``` c++
class Base{
    int s;
    Base(int a){}
}

class Son:public Base{
    int s;
    Son(int a) : Base(a){} //调用父类构造函数
}
```

#### 3、继承中的对象模型

父类中的所有非静态成员属性都会被子类继承，但private权限的属性被编译器隐藏了

``` shell
# 查看类的分布图
# 打开开发人员命令提示工具查看对象模型
cl /d1 reportSingleClassLayout类名 文件名
```

#### 3、继承构造析构顺序

构造先创建父类，再构造子类

析构先析构子类，再析构父类

#### 4、继承同名函数

- 访问子类同名成员，直接访问即可
- 访问父类同名成员，需要添加作用域

``` c++
class base{
    void func(){...}
}

class son:public base {
    void func(){ ... }
}

// 创建一个类
son s1;
// 默认调用子类中的属性，
// 子类会隐藏掉所有的同名函数（父类重载的函数都不会被调用）
// 要想调用父类的重载函数，需要添加作用域
s1.func(); 
// 想调用父类的方法需要添加作用域,调用父类Base中的属性
s1.Base::func();
```

#### 5、同名静态成员

``` c++
class Base{
public:
	static int m_A;    
}
// 类外赋值
int Base::m_A = 100;

class son: public Base{
public:
	static int m_A;    
}
// 类外赋值
int son::m_A = 200;

// 方法一，通过对象访问
son s1;
s.m_A; //访问son类自己的m_A
s.Base::m_A; //访问父类base的m_A属性

// 方法二、通过类名访问
son::m_A; //不用初始化对象
son::Base::m_A //通过子类的父类访问
```

#### 6、多继承

实际开发中不见时使用多继承，因为会有父类函数重名的危险

``` c++
class Base1{}
class Base2{}
// 多继承写法
class son: public Base1, public Base2{
public:
	static int m_A;    
}
```

#### 7、菱形继承

解决方法：使用作用域

### 六、多态（虚函数）

多态分为2类，一是静态多态和动态多态

- 静态多态：函数重载、运算符重载、函数名复用
- 动态多态：派生类、虚函数

静态多态和动态多态的区别

- 静态多态的函数地址-编译的时候确定
- 动态多态的函数地址-运行的时候确定

#### 1、多态的基本语法

多态满足条件：

- 必须有继承关系
- 子类必须重写父类的虚函数（注意，重写是完全相同）

地址早绑定，样例

``` c++
class Animal {
	void speak(){ printf("动物在说话") }
}

class A:public Animal{
    // 重写了父类的speak
	void speak() { printf("A在说话") }
}

// 这里是已经与Animal类绑定的，不能修改
void dospeak(Animal & animal){
	animal.speak(); 
}

int main(){
	A cat;
    // 这里打印的是,动物在说话
	dospeak(cat)
}
```

地址晚绑定，样例

``` c++
class Animal {
    // 这个函数就是虚函数
    // 这个函数可以被其他同名函数替代
	virtual int speak(){ printf("动物在说话") }
}

class A:public Animal{
	int speak(){ printf("A在说话")}
}

// 使用，父类的指针或引用执行子类的对象
void dospeak(Animal& animal){
	animal.speak(); 
}

int main(){
	A cat;
	dospeak(cat)
}
```

#### 2、多态的原理

待补充

#### 3、抽象类（纯虚函数）

只要类中含有一个纯虚函数，那么这个类就是抽象类。抽象类特点

- 无法实例化对象
- 子类必须重写抽象类中的纯虚函数，否则子类也是抽象类
- 抽象类只用.h文件即可，不需要.cpp文件

##### 多文件结构

纯虚函数定义.h文件，不需要.cpp文件

``` c++
class NPC {
    // 纯虚函数，子类必须实现
    virtual void fire(int a)=0; 
}
```

继承虚函数，其他.cpp文件

``` c++
#include "func.h"
// One.h 文件
class One:public NPC {
    // 重写虚函数，virtual可以写也可以不写
    /*
    void fire(int a); 等价于virtual void fire(int a);
    */ 
    virtual void fire(int a);
    
}    
// One.cpp文件，实现虚函数
virtual One::fire(){
    ...
}

/* 调用 */
One o1;
o1.fire(1);
```

##### 单文件结构

``` c++
class One:public NPC {
    // 使用，必须重写类中的纯虚函数
    void fire(int a){
        ....
    }
}

/* 调用 */
One o1;
o1.fire(1);
```



#### 4、虚析构和纯虚析构

在使用多态的时候，父类指针无法调用子类的的析构函数

``` c++
/* 纯虚析构的定义 */
class Animal {
    // 方式一、虚析构必须实现
    // virtual ~Animal(){ ... }
    
    // 方式二、必须定义，定义虚构函数后，让子类重写
    // 这样子类析构的时候，就会调用子类的析构函数
	virtual ~Animal() = 0;
    // 父类虚函数，不重要
    virtual void speak()=0;
} 

// 纯虚析构，需要在内中声明，在类外实现
// 纯虚析构必须得有实现
Animal::~Animal(){
	cout << “animal纯虚析构”;
}

/* 使用虚构函数 */
class Cat:public Animal {
public:
    char *name;
    void Cat(const* name){
        this->name = new char[strlen(name)+1]; 
        strcpy(this->name, name);
    }
	// 注意，这里并未重写父类析构，
    // 但只要父类定义了虚析构函数，就可以调用这里的析构函数
	~Cat() {
		if (this->name !=NULL){
			delete [] this->name;
		}
	}
}

/* 
发生问题原因：
创建的是父类的指针animal,释放的也是父类animal,而我们则是利用多态创建的子类cat，调用的也是子类cat中的speak方法，而没有释放掉子类cat中的堆空间
*/
Animal * animal = new Cat(“TOM”); 
//多态，调用Cat类的speak方法
Animal->speak(); 
delete animal;
```

## 文件操作

文件类型分为两种

- 文本文件：文件以ASCII码形式存放在计算机中
- 二进制文件：文件以文本的二进制形式存储在计算机中

文件操作三大类

- ofstream：写操作
- ifstream：读操作
- fstream：读写操作

### 一、文本文件

文件操作方式：

- ios::in：  读文件的方式打开
- ios::out： 写文件的方式打开
- ios::ate： 初始位置：文件尾
- ios::app： 追加方式写
- ios::trunc： 如果文件存在，先删除在创建
- ios::binary： 二进制方式
- 多方式打开：ios:out | ios::trunc 使用2种方式

#### 1、写操作

``` c++
/* 导入头文件 */ 
#include<fstream>

/*  创建流对象 */
ofstream ofs;
/* 打开文件 */ 
ofs.open(“路径”, ios::in);
/* 写数据 */ 
ofs<< “想要向文本输入的” << endl;
/* 关闭 */ 
ofs.close();
    
/* 判断打开时候成功 */
// 成功返回1,失败返回0
ofs.is_open();
```

#### 2、读文件

``` c++
/* 导入头文件 */ 
#include<fstream>

/* 创建流对象 */
ifstream ifs;
/* 打开文件 */ 
ifs.open(“路径”, ios::out);
/* 读数据、方式一 */ 
char buf[1024] = {0};
// 读的数据放到buf中
while(ifs >> buf){
    //读取完成后，输出
	couf<< buf <<endl; 
}
/* 读数据、方式二 */ 
char buf[1024] = {0};
while( ifs.getline(buf, sizof(buf)) ){
	couf<< buf <<endl; //读取完成后，输出
}
/* 读数据、方式三 */ 
string buf;
while( getline(ifs, buf) ){
	couf<< buf <<endl; //读取完成后，输出
}

/* 关闭 */ 
ofs.close();

/* 判断打开时候成功 */
// 成功返回1,失败返回0
ofs.is_open();

/* 获取数据，放到buf中，每次读取sizfo(buf)个大小 */
ifs.getline(buf, sizeof(buf))
/* 每次获取1个字符 */
char c = ifs.get();
/**/
ifs.eof()
```

### 二、进制文件

文件类型特定为：ios::binary

二进制写文件不建议使用string类型，会有不可预料的错误

#### 1、写文件

``` c++
/* 导入头文件 */ 
#include<fstream>

/* 创建流对象 */
ofstream ofs;
/* 打开文件 */ 
ofs.open(“路径”, ios::out | ios::binary);
/* 写数据 */
Person p = {'张三', 18}；
// 将p类型强转换为char指针类型
ofs.write((const char *)&p, sizeof(Person))
/* 关闭 */ 
ofs.close();
```

#### 2、读文件

``` c++
/* 导入头文件 */ 
#include<fstream>

/* 创建流对象 */
ifstream ifs;
/* 打开文件 */ 
ifs.open(“路径”, ios::in| ios::binary);
/* 读数据*/ 
if (!ifs.is_open()){
    cout<< "打开失败"
        return;
}
// 用于存放数据
Person p;
// 读取的数据放到p中，大小是sizeof(Person)
ifs.read( (char *)&p, sizeof(Person))

/* 关闭 */ 
ofs.close();
```

## 模板-泛型编程

如果普通函数和模板函数发生了重载，优先调用普通函数

如果强制调用模板getMax<>(a,b) ,使用空参数列表

模板可以发生重载

### 模板内部

## 具体化

具体化自定义数据类型

具体化会优先匹配

template<> bool myfunc<Person>(Person &a, Person &b)

{

if(a.name == a.name){}

}

## 模板函数

//定义一个模板函数

// 函数名getMax

template<typename T> //效果与以下一样

template<class T> //T 是一个通用类型，T必须是一个类型，如int，

T getMax(T a, T b) {

return a>b?a:b;

}

 

int main()

{

// 不用特殊定义属性，模板函数会自动返回T类型的值，输入T类型的变量（T类型，是根据你的输入自动变换的）

getMax(1,2)；

getMax(“a”,”b”)；

getMax<int>(1,2)//显示指定类型

}

 

## 模板类

模板定义的变量是可变的，其他的都一样

template<class T,class T2=int>//可以添加默认类型

class LinkList{

T name;

T2 age;

LinkList(T name, T2 age){}

}

int main()

{

string a; int 1;

LinkList<string, int>(a, b) //必须使用显示转换，函数模板可以自动推导，类模板不能推导

}

## 模板做函数参数

void doWork(Person<string, int> &p)

{

P.show()

}

//参数模板化

template<class T1, class T2>

void doWork(Person<T1, T2>&p){...}

## 类模板与继承

template<class T>

class Base

{

public:

T m_A;

}

 

//必须告诉child类型,否则不能分配内存

class Child: public Base<int> {}

 

//由用户指定类型

template<class T1, class T2>

class Child: pulbic Base<T2>

{}

## 模板的份文件编写

1、模板的文件是.hpp

2、方法实现与声明放到同一个文件中

因为C语言是份文件编译，但模板文件类型是在运行时确定，所以不能使用.h方法引入

可以直接引入.cpp文件，

模板文件编译在运行时会出错

 

## 模板与友元函数

## 异常

### 一、基本语法

``` c++
try{} catch(int) {}//捕获int类型异常

try{} catch(){} catch(){} //捕获多个异常

try{} catch(...){} //捕获其他类型异常

 

throw 1//抛出异常，可被catch抓到

throw 3.14//抛出double异常

 自定义异常类

class my Exception

{

public:

void myException();

}

 

throw MyException(); //抛出异常类

catch(MyException e)
```

### 二、栈解旋

从try开始，到throw抛出异常之前，所有栈上的对象都会被释放

### 三、异常接口声明

void func() throw() //不能抛出任何异常

void func() throw(int) //抛出int类型异常,当前函数只能抛出int错误

{

throw 1;

}

### 四、异常生命周期

throw new MyException();

catch(MyException *e)

{

delete e;

}

### 五、异常多态

### 六、标准异常库

\#include<stdexcept>

throw out_of_range(“年龄越界”); //越界异常

e.what() //异常信息



# ## STL（标准模板库）

分为容器，算法，迭代器

## 三大组件-容器-算法-迭代器

迭代器：

include<vector>

vector<int> v;//声明一个容器，int类型，对象名称为v

v.push_back(10); //尾插

 

vector<int>::iterator it = v.begin();//it指向容器起始位置

vector<int>::iterator itEnd = v.end();//容器最后位置的下一个

 

for( vector<int>::iterator it = v.begin();it ！=v.end();i++)

{

cout<< *it<<endl;

}

 

while(it != itEnd)

{

cout<< *it;

it++

}

 

 

 

include<algorithm> //算法头文件

void myPrint(int a);

for_each(v.begin(), v.end(), myPrint);//遍历

自定义类型

class Person{}

vector<Person> P

 

vector<vector<int>> v;//容器列表

vector<int> v1;

v.push_back(v1)

## string容器-类

include<string>

C风格字符串太过复杂，不适合大程序开发

char* 是一个指针，string是一个类，sting内部管理一个char*

string封装了很多实用成员方法

不用考虑内存释放和越界

string str;默认构造

string str2(str) //拷贝构造

string str3 = “abcd”; //string str3 = string(“123”)

 

str = “123”; //重写了=号

str = str4; //多态构造=号，&a

 

str.size() //字符串大小

str.at(i) == str[i] //表现一样，【】访问越界挂掉，at会抛出异常

str.append(“xxxx”) //尾部追加

str.find(“b”)//查找从0开始，最先查找的位置，没找到返回-1

str.replace(1,2,”111”) //替换

str.compare(str2) //字符串根据ASCII码对比

str.substr(0, 3)//返回从0开始的3个字符串

 

const char * p = s.c_str(); //转换为C风格字符串

string s2(p) //转换为string类型的字符串

//隐式类型能从const char * 转换为string.但不能从string转换为const char*

toupper(a) //将字符转换为大写

tolower(a) //转换为小写

注意

string a = “123456”;

a[1] =’a’//这样修其中的字符

a = ‘1234567890’;//这里字符过长，内存重新分配

## vector-栈结构-单钻数组-动态数组

push_back()

vector<int>v2(v1.begin(), v1.end());

.size()// 返回容器中元素的个数

.empty()//判断容器是否为空

.resize(int num);//重新指定容器长度为num,若容器变长则以默认值填充

capacity()

reserve()

 

vector<int>(v).swap(v)//节省空间

 

## deque-队列

s双端数组，没有容量，

push_front()

push_back()

pop_front()

pop_back();

 

deque<int> d;

 

iterator//普通迭代器

reverse_iterator//逆序迭代器

const_iterator//只读迭代器

## stack容器

先进后出的容器-不允许有遍历行为-没有迭代器

include<stack>

stack<T> a; //stack采用模板类实现，stack<int> a;

a. push(10) //添加元素

a. pop() //弹出一个数据

a. size() //读取stack大小， while(s.size() !=0 )// empty

a. top() //访问栈顶元素-不弹出

a.empty()//判断是否为空

## queue容器

先进先出-但只能再队尾添加，队头删除-没有迭代器

queue<int> a;

a. push(10) //队尾添加元素

a. pop() //对头弹出

a. empty() //判断是否为空

a. front() //查看队头元素

a. back() //查看队尾元素

## list容器-双向循环链表

动态分配，不会造成内存浪费和溢出-提供双向迭代器

不支持随机访问

\#include <list>

list<int> m; //定义一个

list<int> m(10， 10) //构造方式

m.push_back() //尾插

m.push_front() //头插

m.pop_front() //弹出

m.pop_back() //尾弹出

m.clear()//删除

m.insert(m, 100) //

m.arase()

m.remove(10) //删除指定值，所有值

m.assign()

m.reverse()//反转排序， 所用不支持随机访问的迭代器，不可以用系统提供算法

 

//对于自定义排序，需要指定排序规则

m.sort(mysort) //排序

bool mysort(Person &p1, Person &2)

{

if(p1.mage> p2.mage)

{

return true

}else{

return false

}

}

 

## set容器

根据元素进行排序，不允许有2个相同的值，不允许修改

multiset 容器，红黑二叉树

s1.insert()返回值是pair

 

set<int> s1;

s1.insert() //插入值 -关联式容器，会自动排序

s1.erase() //删除，可传值

s1.find()//返回一个迭代器 set<int>::iterator pos = s1.find(3),未找到返回s1.end()

s1.count()//

s1.lower_bound(keyElem)

 

pair对组

pair<set<int>::iterator,set<int>::iterator> res = s1.equal_range(0)

ret.first //第一个值

ret.second //第二个值

 

创建队组

pair<string, int> p2=make_pair(“jjjj”,200)//创建

pair<string, int> p(string(“tom”),100) //创建

p.first

p.second

 

插入前设置排序规则-插入自定义排序，需要指定排序规则

set<int, mycompare>s1 //默认从小到大排序

class mycompare{

public:

bool operator()(int v1, int v2)

{

return v1>v2;

}

}

 

## map容器

所有元素会按照key排序，不允许有2个相同的key值-红黑树实现

include<map>

map<int, int> m;

m.insert(make_pair(2,20));

m[n] = 33; //系统会摩天使用0填充

 

m.clear() //删除

m.erase()//删除指定值

 

## 使用时机

vector ke

## 算法-函数对象-仿函数-类-重写了（）

一元谓词 二元谓词

 

\#include<algorithm>

<numeric>小体积

<functional>

//这里function是一个函数对象，

vector<int>::iterator pos = find_if(begin,end, function())

class function

{

public:

//重载()

}

## 遍历算法

callback可以是函数，仿函数

for_each(iterator begin, iterator end, callback)

myprint p = for_each()

p.m_Count

 

vector<int>v;

v.resize(v.size()) //开辟空间

transform() //搬运数据，不会开辟空间

## 查找算法

find(start,end, value) 返回一个迭代器

自定义数据

binary_search()//二分查找，必须有序序列

## 排序算法

sort()

merge() //合并，必须有序

random_shuffle(begin, end) //将指定数组随机排序，需要自己提供种子

reverse() //反转

## 拷贝和替换

copy()

replace()

replace_if()

swap()

## 算数生成

include<numeric>

accumulate(begin, end, 0) //计算元素累计总和,累加计算，最后一个是起始值

fill() //向容器中填充元素

## 集合算法

交集，并集，差集（两个集合相减）返回值是集合的最后一个位置

set_intersection() //交集min(v1.size(), v2.size())

set_union()//并集vi.size() + v2.size()

 

 

## lambda表达式

[](int a){cout<<”ss”}

## 内建函数对象

include<functional>

//template<class T> negate<T>

negate<int> v;//取反

cout<< v(10) ;//-10

 

plus<int> p;

cout<< p(1,1) //加法

 

## 适配器

提供函数应提供函数名，提供仿函数function()

# 类型转换

向下转换不安全，线上转换安全

**静态转换**

类属性转换必须有父子关系

基础类型转换

char a=”a”;

doublie b = static_cast<double>(a);//静态类型转换成double

**动态转换**

**基础类型不允许转换，失去精度或不安全都不可以转换**

**只能向下转换**

char a=”a”;

double d = dynamic_cast<double>(a);

常量转换

不能直接对非指针或引用使用

const int *p = NULL;

int* p = const_cast<int *>(p);//去掉const

 

int* p2=NULL;

const int p2 = const_cast<int *>(p2); //添加const

 

 

 

# C++11 新特性

## 1、auto 自动实现类型转换，

auto 可以指向任何函数，实现类型转换【弱类型语言】

auto 定义的就是，任意类型语言，可以放任何东西

 

## 2、增强的for循环

**[****可以理解成for...in]**

for(auto tmp:allNPC){

//tmp是allNPC中的每一个值

tmp->move(30,40) //移动

}

 

## 3、lambda 匿名函数

[] 使用外部变量

auto a = **[**=赋值方式、&引用方式**](**参数**){**代码块**}**

a(); //调用
